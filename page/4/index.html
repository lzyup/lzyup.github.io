<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Luzy&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Luzy&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Luzy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Luzy's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Luzy's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Luzy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/03/SSR%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luzy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Luzy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/03/SSR%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">SSR指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-03 10:41:52" itemprop="dateCreated datePublished" datetime="2024-09-03T10:41:52+08:00">2024-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/SSR%E6%8C%87%E5%8D%97/" itemprop="url" rel="index"><span itemprop="name">SSR指南</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="SSR的作用"><a href="#SSR的作用" class="headerlink" title="SSR的作用"></a>SSR的作用</h3><ul>
<li>seo问题，有利于搜索引擎蜘蛛抓取网站内容，利于网站的收录和排名</li>
<li>首屏加载过慢的问题，例如现在成熟的SPA项目中，打开首页需要加载很多资源，通过服务端渲染可以加速首屏渲染。</li>
</ul>
<p>首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。</p>
<h3 id="实战demo"><a href="#实战demo" class="headerlink" title="实战demo"></a>实战demo</h3><p><a href="https://github.com/lzyup/vue-ssr">源码地址</a></p>
<h3 id="一、-简单的前端渲染demo-纯展示"><a href="#一、-简单的前端渲染demo-纯展示" class="headerlink" title="一、 简单的前端渲染demo(纯展示)"></a>一、 简单的前端渲染demo(纯展示)</h3><p>这个比较简单就直接上效果图了</p>
<p><img src="https://raw.githubusercontent.com/lzyup/vue-ssr/master/demo1/images/demo1.jpg" alt="效果图"></p>
<h3 id="二、后端渲染（纯展示）"><a href="#二、后端渲染（纯展示）" class="headerlink" title="二、后端渲染（纯展示）"></a>二、后端渲染（纯展示）</h3><h4 id="1、区分入口entry-js"><a href="#1、区分入口entry-js" class="headerlink" title="1、区分入口entry.js"></a>1、区分入口entry.js</h4><h4 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a><code>main.js</code></br></h4><p>这是应用的通用<code>entry</code>。作用是使用<code>export</code>导出一个<code>createApp</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Vue = require(&#x27;vue&#x27;);</span><br><span class="line">const App = require(&#x27;./App.vue&#x27;).default;</span><br><span class="line"></span><br><span class="line">//导出一个工厂函数，用于创建新的</span><br><span class="line">//应用程序、router和store实例</span><br><span class="line">function createApp()&#123;</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">        render: h =&gt; h(App)</span><br><span class="line">    &#125;)</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = createApp;</span><br></pre></td></tr></table></figure>

<h4 id="entry-client-js"><a href="#entry-client-js" class="headerlink" title="entry-client.js"></a><code>entry-client.js</code></br></h4><p>客户端创建应用并挂载到DOM上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const createApp = require(&#x27;./main&#x27;)</span><br><span class="line">const app = createApp();</span><br><span class="line">app.$mount(&#x27;#app&#x27;);</span><br></pre></td></tr></table></figure>

<h4 id="entry-server-js"><a href="#entry-server-js" class="headerlink" title="entry-server.js"></a><code>entry-server.js</code></br></h4><p>服务器entry使用工厂函数创建的实例，在每次渲染中重复调用此函数。此时，除了创建和返回应用程序实例之外，它不会做太多的事情。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const createApp = require(&#x27;./main.js&#x27;);</span><br><span class="line">module.exports = createApp;</span><br></pre></td></tr></table></figure>

<h4 id="2、区分webpack打包配置"><a href="#2、区分webpack打包配置" class="headerlink" title="2、区分webpack打包配置"></a>2、区分<code>webpack</code>打包配置</h4><p>分为三个配置文件：base,client和server。基本配置(base config)包含两个环境共享的配置，例如：输出路径(output path),别名(alias)和loader。服务器配置(server config)和客户端配置(client config)，可以通过使用<code>webpack-merge</code>来简单地扩展基本配置。</p>
<p>这里只贴出服务端配置</p>
<h4 id="服务器配置-Server-Config"><a href="#服务器配置-Server-Config" class="headerlink" title="服务器配置(Server Config)"></a>服务器配置(Server Config)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const merge = require(&#x27;webpack-merge&#x27;);</span><br><span class="line">const base = require(&#x27;./webpack.base.conf&#x27;);</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = merge(base,&#123;</span><br><span class="line">    //指定Node环境，避免非Node环境API报错</span><br><span class="line">    target:&#x27;node&#x27;,</span><br><span class="line">    entry:&#123;</span><br><span class="line">        server:&#x27;./entry-server.js&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&#x27;[name].js&#x27;,</span><br><span class="line">        //此处告知 server bundel使用Node风格导出模块</span><br><span class="line">        libraryTarget:&#x27;commonjs2&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template:&#x27;./index.ssr.html&#x27;,</span><br><span class="line">            filename:&#x27;index.ssr.html&#x27;,</span><br><span class="line">            files:&#123;</span><br><span class="line">                js:&#x27;client.js&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            excludeChunks:[&#x27;server&#x27;]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lzyup/vue-ssr/master/demo2/images/demo2.jpg" alt="效果图"></p>
<h4 id="3、服务端渲染逻辑"><a href="#3、服务端渲染逻辑" class="headerlink" title="3、服务端渲染逻辑"></a>3、服务端渲染逻辑</h4><p><code>vue-server-render</code>提供一个<code>createBundleRenderer</code>的API，支持热重载（支持更新后的server的bundle文件，然后重新创建renderer实例）</br><br>相关逻辑代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const bundle = fs.readFileSync(path.resolve(__dirname,&#x27;dist/server.js&#x27;),&#x27;utf-8&#x27;);</span><br><span class="line">const renderer = require(&#x27;vue-server-renderer&#x27;).createBundleRenderer(bundle,&#123;</span><br><span class="line">    template:fs.readFileSync(path.resolve(__dirname,&#x27;dist/index.ssr.html&#x27;),&#x27;utf-8&#x27;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.get(&#x27;/index&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    // const app = createApp();</span><br><span class="line">    const context = &#123;url:req.url&#125;</span><br><span class="line">    //这里无需传入一个应用程序，因为在执行bundle时已经自动创建过了</span><br><span class="line">    renderer.renderToString(context,(err,html)=&gt;&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            console.error(err);</span><br><span class="line">            res.status(500).end(&#x27;服务器内部错误&#x27;)</span><br><span class="line">            return;</span><br><span class="line">        &#125; </span><br><span class="line">        res.end(html)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>bundleRender在调用<code>renderToString</code>时，会自动执行「由bundle创建的应用程序实例」所导出的函数（传入上下文作为参数），然后渲染它。</p>
<h3 id="三、后端渲染（包含网络请求数据）"><a href="#三、后端渲染（包含网络请求数据）" class="headerlink" title="三、后端渲染（包含网络请求数据）"></a>三、后端渲染（包含网络请求数据）</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>在渲染之前，预先获取所有的网络数据，然后存储到Vuex的Store中</li>
<li>后端渲染的时候，通过Vuex将获取到的网络数据分别注入到各个组件中</li>
<li>将全部网络数据埋在<code>window.INITIAL_STATE</code>中，通过HTML传递到浏览器端</li>
<li>浏览器端通过Vuex将<code>window.INITIAL_STATE</code>里面的网络数据分别注入到各个组件</li>
</ul>
<h4 id="配置带逻辑的组件"><a href="#配置带逻辑的组件" class="headerlink" title="配置带逻辑的组件"></a>配置带逻辑的组件</h4><p>在组件上暴露一个自定义静态函数<code>asyncData</code>。需要注意的是，此函数会在组件实例化之前调用，所以它无法访问<code>this</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">function fetchBar()&#123;</span><br><span class="line">    return new Promise(function (resolve,reject) &#123;</span><br><span class="line">        resolve(&#x27;bar ajax 返回数据&#x27;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fetchFoo() &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        resolve(&#x27;foo ajax 返回数据&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function createStore()&#123;</span><br><span class="line">    return new Vuex.Store(&#123;</span><br><span class="line">        state:&#123;</span><br><span class="line">            bar:&#x27;&#x27;,</span><br><span class="line">            foo:&#x27;&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        actions:&#123;</span><br><span class="line">            fetchBar(&#123;commit&#125;)&#123;</span><br><span class="line">                return fetchBar().then(msg=&gt;&#123;</span><br><span class="line">                    commit(&#x27;setBar&#x27;,&#123;msg&#125;);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            fetchFoo(&#123; commit &#125;) &#123;</span><br><span class="line">                return fetchFoo().then(msg =&gt; &#123;</span><br><span class="line">                    commit(&#x27;setFoo&#x27;, &#123; msg &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mutations:&#123;</span><br><span class="line">            setBar(state,&#123;msg&#125;)&#123;</span><br><span class="line">                Vue.set(state,&#x27;bar&#x27;,msg);</span><br><span class="line">            &#125;,</span><br><span class="line">            setFoo(state,&#123;msg&#125;)&#123;</span><br><span class="line">                Vue.set(state,&#x27;foo&#x27;,msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Bar.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;bar&quot;&gt;</span><br><span class="line">        &lt;h1&gt;Bar&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;ajax数据：&#123;&#123;bar&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    asyncData(&#123;store&#125;)&#123;</span><br><span class="line">        return store.dispatch(&#x27;fetchBar&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        bar()&#123;</span><br><span class="line">            return this.$store.state.bar</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        console.log(&#x27;bar created&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .bar&#123;</span><br><span class="line">        background:#9e9ecd</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="如何在渲染前预获取所有网络数据"><a href="#如何在渲染前预获取所有网络数据" class="headerlink" title="如何在渲染前预获取所有网络数据"></a>如何在渲染前预获取所有网络数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//entry-server.js</span><br><span class="line"></span><br><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line">import App from &#x27;./App.vue&#x27;;</span><br><span class="line">import createStore from &#x27;./store&#x27;;</span><br><span class="line"></span><br><span class="line">export default function(context)&#123;</span><br><span class="line">    //context 是 vue-server-render注入参数</span><br><span class="line">    const store = createStore();</span><br><span class="line">    let app = new Vue(&#123;</span><br><span class="line">        store,</span><br><span class="line">        render:h=&gt;h(App)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //找到所有prefetchData方法</span><br><span class="line">    let components = App.components;</span><br><span class="line">    let prefetchFns = [];</span><br><span class="line">    for(let key in components)&#123;</span><br><span class="line">        if(!components.hasOwnProperty(key)) continue;</span><br><span class="line">        let component = components[key];</span><br><span class="line">        if(component.asyncData)&#123;</span><br><span class="line">            prefetchFns.push(component.asyncData(&#123;</span><br><span class="line">                store</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Promise.all(prefetchFns).then((res)=&gt;&#123;</span><br><span class="line">        //在所有组件的Ajax都返回之后，才最终返回app进行渲染</span><br><span class="line">        context.state = store.state;</span><br><span class="line">        //context.state 赋值成什么，windwo.__INITIAL_STATE__就是什么</span><br><span class="line">        return app;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为何还需要将网络请求得到的数据通过window-INITIAL-STATE传递到前端？"><a href="#为何还需要将网络请求得到的数据通过window-INITIAL-STATE传递到前端？" class="headerlink" title="为何还需要将网络请求得到的数据通过window.INITIAL_STATE传递到前端？"></a>为何还需要将网络请求得到的数据通过<code>window.INITIAL_STATE</code>传递到前端？</h4><p>可以看到我们打包出来的<code>dist</code>目录下的<code>index.ssr.html</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;!--vue-ssr-outlet--&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;client.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>注意到引入的<code>script</code>是<code>client.js</code>接管浏览器端的后续操作；而且客户端和浏览器也是通过工厂函数分别创建的<code>vue实例</code>和<code>store实例</code>，数据也是互不干扰的。浏览器中后续的操作是<code>client.js</code>来接管的，因此需要把网络数据写入<code>window.INITIAL_STATE</code>中，使<code>client.js</code>保持同样一份数据。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://github.com/youngwind/blog/issues/112">link1</a></br><br><a href="https://segmentfault.com/a/1190000016637877#item-2-1">link2</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/03/Web%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luzy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Luzy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/03/Web%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">Web安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-03 10:41:52" itemprop="dateCreated datePublished" datetime="2024-09-03T10:41:52+08:00">2024-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<h2 id="Web-安全"><a href="#Web-安全" class="headerlink" title="Web 安全"></a>Web 安全</h2><p><a href="https://github.com/lzyup/FE-Security">实战 Demo</a></p>
</blockquote>
<blockquote>
<h3 id="1、CSRF"><a href="#1、CSRF" class="headerlink" title="1、CSRF"></a>1、CSRF</h3><p>（Cross-site request forgery）跨站点请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
</blockquote>
<h4 id="1-2-特征"><a href="#1-2-特征" class="headerlink" title="1.2 特征"></a>1.2 特征</h4><p>冒用用户身份，进行恶意操作</br><br><img src="https://segmentfault.com/img/remote/1460000012693783?w=904&h=739" alt="image"></p>
<h4 id="1-3-典型攻击流程"><a href="#1-3-典型攻击流程" class="headerlink" title="1.3 典型攻击流程"></a>1.3 典型攻击流程</h4><ul>
<li>受害者登录 A 站点，并保留了凭证(Cookie)</li>
<li>攻击者诱导受害者访问了站点 B</li>
<li>站点 B 向站点 A 发送了一个请求，浏览器默认携带站点 A 的 Cookie 的信息</li>
<li>站点 A 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。</li>
<li>站点 A 以受害者的名义执行了站点 B 的请求</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充了受害者完成了攻击。</li>
<li></li>
</ul>
<h4 id="1-4-防御手段"><a href="#1-4-防御手段" class="headerlink" title="1.4 防御手段"></a>1.4 防御手段</h4><ul>
<li>添加验证码（体验不好）</li>
<li>判断请求的来源：检测 Referer(并不安全，Referer 可以被更改)</li>
<li>使用 Toekn(主流)</br></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CFRS攻击之所以能够成功，是因为服务器误把攻击者发送的请求当做用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token,来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知</span><br><span class="line"></span><br><span class="line">- 服务器端给用户生成一个token,加密后传递给用户</span><br><span class="line">- 用户在提交请求时，需要携带这个token</span><br><span class="line">- [服务端验证token是否正确](https://note.youdao.com/)</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="2、-XSS"><a href="#2、-XSS" class="headerlink" title="2、 XSS"></a>2、 XSS</h3><p>(Cross-Site Scripting,跨站脚本攻击)</p>
</blockquote>
<p>特征：</p>
<p>跨域脚本注入，攻击者通过某种方式将恶意代码注入到网页上，然后其他用户观看到被注入的页面内容后会受到特定攻击</p>
<h4 id="2-1-反射型-XSS"><a href="#2-1-反射型-XSS" class="headerlink" title="2.1 反射型 XSS"></a>2.1 反射型 XSS</h4><p>用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等，<strong>未进行过滤直接返回到用户的浏览器上</strong></p>
<h4 id="2-2-DOM-型-XSS"><a href="#2-2-DOM-型-XSS" class="headerlink" title="2.2 DOM 型 XSS"></a>2.2 DOM 型 XSS</h4><p>DOM 型 XSS 攻击，实际上就是前端<code>JavaScript</code>代码不够严谨，把不可信的内容插入到页面。在使用<code>.innerHTML</code>、<code>outerHTML</code>、<code>.appendChild</code>、<code>document.write()</code>等 API 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用<code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute()</code>等</p>
<h4 id="2-3-存储型-XSS"><a href="#2-3-存储型-XSS" class="headerlink" title="2.3 存储型 XSS"></a>2.3 存储型 XSS</h4><p>恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和 DOM 型 XSS 更大。存储型 XSS 攻击的原因仍然是没有做好数据过滤:前端从服务器请求到数据，没有过滤输出</p>
<p><a href="https://juejin.im/post/5cd6ad7a51882568d3670a8e#heading-5">参考链接</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/03/babel%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luzy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Luzy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/03/babel%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">babel插件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-03 10:41:52" itemprop="dateCreated datePublished" datetime="2024-09-03T10:41:52+08:00">2024-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JS%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">JS相关</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JS%E7%9B%B8%E5%85%B3/babel/" itemprop="url" rel="index"><span itemprop="name">babel</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1、什么是-babel"><a href="#1、什么是-babel" class="headerlink" title="1、什么是 babel"></a>1、什么是 babel</h2><p>Babel 是 <code>JavaScript</code> 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器（<code>transpiler</code>）”。 意思是说你为 Babel 提供一些 <code>JavaScript</code> 代码，Babel 更改这些代码，然后返回给你新生成的代码。</p>
<h2 id="2、babel-工作流程"><a href="#2、babel-工作流程" class="headerlink" title="2、babel 工作流程"></a>2、babel 工作流程</h2><h3 id="2-1-parse-解析"><a href="#2-1-parse-解析" class="headerlink" title="2.1 parse(解析)"></a>2.1 <code>parse</code>(解析)</h3><p><code>parse</code>解析源代码，生成抽象语法树；将源代码解析生成 AST 抽象语法树，其中包括词法分析(<code>Lexical Analysis</code>)和语法分析(<code>Syntactic Analysisi</code>)两个阶段。</p>
<h3 id="2-2-transform-转换"><a href="#2-2-transform-转换" class="headerlink" title="2.2 transform(转换)"></a>2.2 <code>transform</code>(转换)</h3><p><code>transform</code>对<code>AST</code>树进行遍历，对其节点做各种操作（删除、更新、新增等，这是 Babel 编译器中最复杂的过程，同时也是插件介入工作的部分。将源代码版本的<code>AST</code>转换成目标版本的<code>AST</code>）。</p>
<h3 id="2-3-generate-生成"><a href="#2-3-generate-生成" class="headerlink" title="2.3 generate(生成)"></a>2.3 <code>generate</code>(生成)</h3><p>最后由<code>generate</code>将目标版本的<code>AST</code>生成目标代码（将 AST 对象转换成字符串形式的代码，同时还会创建源码映射<code>sourcemap</code>）</p>
<h2 id="3、babel-工具"><a href="#3、babel-工具" class="headerlink" title="3、babel 工具"></a>3、babel 工具</h2><ul>
<li><code>@babel/parser</code>用来解析源代码；</li>
<li><code>@babel/traverse</code>用于遍历<code>AST</code>，并调用 visitor 函数修改<code>AST</code>节点；</li>
<li><code>@babel/types</code>是一个用于<code>AST</code>节点的<code>Loadash</code>式工具库，包含构造、验证以及变换<code>AST</code>节点的方法</li>
<li><code>@babel/template</code>是另一个虽然很小但很有用的模块，能让你编写字符串形式且代用占位符的代码来代替手动编码，尤其是快速生成的大规模<code>AST</code>的时候，用它比一个一个用<code>@babel/types</code>生成拼接的<code>AST</code>好用太多了</li>
<li><code>@babel/generator</code>将<code>AST</code>转换成目标代码</li>
<li><code>@babel/cores</code>涵盖了上述所有包的功能，可以完成从编译、转换到生成代码和<code>sourcemap</code>中所有的流程。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/03/CSRF%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E6%8A%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luzy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Luzy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/03/CSRF%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E6%8A%A4/" class="post-title-link" itemprop="url">CSRF原理与防护</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-03 10:41:52" itemprop="dateCreated datePublished" datetime="2024-09-03T10:41:52+08:00">2024-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-11 15:12:13" itemprop="dateModified" datetime="2024-09-11T15:12:13+08:00">2024-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1、Cookie-的特性"><a href="#1、Cookie-的特性" class="headerlink" title="1、Cookie 的特性"></a>1、Cookie 的特性</h2><ul>
<li>浏览器默认自动携带本次 HTTP 请求域名的 Cookie</li>
<li>读写 Cookie 有跨域限制(作用域，Domain,Path)</li>
<li>生命周期（会话或者持久）</li>
</ul>
<h2 id="2、CSRF-攻击过程"><a href="#2、CSRF-攻击过程" class="headerlink" title="2、CSRF 攻击过程"></a>2、CSRF 攻击过程</h2><p>登录态 Cookie 的 Key 是浏览器默认自动携带的，Key 通常是会话 Cookie，只要浏览器不关闭，Key 一直存在。所以只要用户 A 登录过网站（<a href="http://www.test.com),浏览器没有关闭,用户在没有关闭的浏览器打开一个黑客网页(www.hacker.com),黑客页面发送一个http请求到www.test.com的后台会默认带上www.test.com的登录态cookie,也就能模拟一些增删改查等敏感操作.get和post都一样,这就是csrf攻击原理./">www.test.com），浏览器没有关闭，用户在没有关闭的浏览器打开一个黑客网页（www.hacker.com）,黑客页面发送一个HTTP请求到www.test.com的后台会默认带上www.test.com的登录态cookie，也就能模拟一些增删改查等敏感操作。Get和Post都一样，这就是CSRF攻击原理。</a></p>
<h2 id="3、防护方案-Token"><a href="#3、防护方案-Token" class="headerlink" title="3、防护方案 Token"></a>3、防护方案 Token</h2><p>由于 Cookie 有跨域限制，所以我们可以用这个特性来区分自己页面还是黑客页面。只要页面能读（或者写）<a href="http://www.test.com域名cookie,就证明是自己的页面.方案很简单,比如服务器通过cookie下发一个token,token值是随机数,页面发请求的时候从cookie取出token通过http请求参数传给后台,后台对比参数里的token和cookie里的token是否一致./">www.test.com域名Cookie,就证明是自己的页面。方案很简单，比如服务器通过cookie下发一个token，token值是随机数，页面发请求的时候从cookie取出token通过HTTP请求参数传给后台，后台对比参数里的token和cookie里的token是否一致。</a></p>
<h3 id="3-1-Token-是谁生成的"><a href="#3-1-Token-是谁生成的" class="headerlink" title="3.1 Token 是谁生成的"></a>3.1 Token 是谁生成的</h3><p>原理上，token 前端后端生成都可以，只要保证随机性。如果是前端生成 token 然后写到 Cookie 里，然后 HTTP 请求参数也带上 token,后端逻辑一样对比参数里面的 token 和 cookie 里面的 token 是否一致，如果一致就证明是自己页面发出的请求，如果不一致就返回失败。这就是 Cookie 读和写的区别，只要能读写自己域名的 Cookie 就是自己的页面。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/03/Context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luzy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Luzy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/03/Context/" class="post-title-link" itemprop="url">Context</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-03 10:41:52" itemprop="dateCreated datePublished" datetime="2024-09-03T10:41:52+08:00">2024-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="context是什么"><a href="#context是什么" class="headerlink" title="context是什么"></a><code>context</code>是什么</h3><p><code>context</code>提供了一种通过组件树传递数据的方法，无需每个级别手动传递 props 属性即全局共享数据</p>
<h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>以主题色<code>theme</code>为例</p>
<h4 id="不使用context时"><a href="#不使用context时" class="headerlink" title="不使用context时"></a>不使用<code>context</code>时</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;Toolbar theme=&quot;dark&quot; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Toolbar(props)&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ThemeButton theme=&#123;props.theme&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThemeButton extends React.Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;Button theme=&#123;this.props.theme&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用context时"><a href="#使用context时" class="headerlink" title="使用context时"></a>使用<code>context</code>时</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//为当前theme创建一个context（&#x27;light&#x27;为默认值）</span><br><span class="line">const ThemeContext = React.createContext(&#x27;light&#x27;);</span><br><span class="line">class App extends React.component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        //使用一个Provider来将当前的theme传递给以下组件树</span><br><span class="line">        //无论多深，任何组件都能读取这个值</span><br><span class="line">        return (</span><br><span class="line">            &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;</span><br><span class="line">                &lt;Toolbar /&gt;</span><br><span class="line">            &lt;/ThemeContext.Provider&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ToolBar()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ThemeButton /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThemeButton extends React.Component&#123;</span><br><span class="line">    //挂载在class上的`contextType`属性会被重赋值为一个由React.createContext()创建的Context对象。</span><br><span class="line">    //这样就能使用this.context来消费最近Context上的那个值</span><br><span class="line">    static contextType = ThemeContext;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;Button theme=&#123;this.context&#125; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/03/ESLint-%E4%B8%8E-Prettie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luzy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Luzy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/03/ESLint-%E4%B8%8E-Prettie/" class="post-title-link" itemprop="url">ESLint 与 Prettie</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-03 10:41:52" itemprop="dateCreated datePublished" datetime="2024-09-03T10:41:52+08:00">2024-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/ESlint/" itemprop="url" rel="index"><span itemprop="name">ESlint</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="eslint-prettier-editorconfig-lint-staged"><a href="#eslint-prettier-editorconfig-lint-staged" class="headerlink" title="eslint+prettier+editorconfig+lint-staged"></a><code>eslint</code>+<code>prettier</code>+<code>editorconfig</code>+<code>lint-staged</code></h2><h2 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a><code>ESlint</code></h2><p>开发过程中，如果写出不合符规范的代码，能够及时提醒开发者，及时修复</p>
<p>通常，需要较大变动才能修复的规范问题，eslint 无法自动修复。如：单行不超过 80 个字符</p>
<p>针对代码质量问题，例如：未使用变量、三等号、全局变量生命问题</p>
<h2 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a><code>Prettier</code></h2><p>保存代码，使用格式化快捷键，能够自动按照我们制定的规范、格式化代码</p>
<p>针对代码格式问题，例如：单行代码长度、tab 长度、空格、逗号表达式</p>
<h2 id="editorconfig"><a href="#editorconfig" class="headerlink" title="editorconfig"></a><code>editorconfig</code></h2><p>用于覆盖编辑器（针对不同编辑器，vscode,webstorm）默认的配置</p>
<h2 id="为什么要两者结合"><a href="#为什么要两者结合" class="headerlink" title="为什么要两者结合"></a>为什么要两者结合</h2><p><code>ESLint</code>擅长校验，<code>prettier</code>擅长格式；但是两者有些规则是冲突的</p>
<h3 id="ESLint中的-extends"><a href="#ESLint中的-extends" class="headerlink" title="ESLint中的 extends"></a><code>ESLint</code>中的 extends</h3><p>用别人定义好的规则集，直接拿过来用</p>
<ul>
<li>eslint 开头的，就是 eslint 官方的扩展，如<code>eslint:recommend</code>(推荐规范)和<code>eslint:all</code>(所有规范)</li>
<li>eslint-config 开头的，比如第三方发布到 npm 上的，如<code>eslint-config-airbnb</code>(airbnb 的规范)，<code>eslint-config-alloy</code>（Alloy team 的规范）等</li>
<li>plugin 开头的，就是通过插件共享的规则，如<code>eslint-plugin-vue</code>,通常一个插件会提供多套规则</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>禁掉 ESLint 中与 Prettier 冲突的规则，然后使用 Prettier 做格式化， ESLint 做代码校验</p>
<ul>
<li><p>首先禁掉 ESLint&#x2F;插件中与 Prettier 冲突的规则，创建一个包<code>eslint-confit-prettier</code>,里面定义了被禁掉的 ESLint&#x2F;插件规则</p>
</li>
<li><p>创建一个插件<code>eslint-plugin-prettier</code>,定义一条规则 prettier&#x2F;prettier，调用 Prettier,配合 ESLint 实现运行<code>eslint --fix</code>按 Prettier 规则自动化格式代码</p>
</li>
<li><p>在.eslintrc.js 中如下配置</p>
<p>{<br>extends: [<br>…, &#x2F;&#x2F; 其他<br>“prettier”, &#x2F;&#x2F; eslint-config-prettier<br>]<br>plugins: [“prettier”], &#x2F;&#x2F; eslint-plugin-prettier<br>rules: {<br>“prettier&#x2F;prettier”: “error” &#x2F;&#x2F; 开启规则<br>}<br>}</p>
</li>
</ul>
<h3 id="eslint-config-prettier"><a href="#eslint-config-prettier" class="headerlink" title="eslint-config-prettier"></a><code>eslint-config-prettier</code></h3><p>让所有可能会与 prettier 规则存在冲突的 eslint rule 失效即关闭 ESLint 与 Prettier 冲突的规则。</p>
<pre><code>&quot;extends&quot;:[
    &quot;eslint:recommend&quot;,
    &quot;prettier&quot;
]
</code></pre>
<h3 id="eslint-plugin-prettier"><a href="#eslint-plugin-prettier" class="headerlink" title="eslint-plugin-prettier"></a><code>eslint-plugin-prettier</code></h3><p>将 prettier 的能力集成到 eslint 中。以 ESlint 规则的方式运行 Prettier 检查代码规范性，并进行修复</p>
<pre><code>&#123;
    &quot;rules&quot;:&#123;
        &quot;prettier/prettier&quot;: &quot;error&quot;
    &#125;,
    &quot;plugins&quot;:[&quot;prettier&quot;]
&#125;
</code></pre>
<h3 id="Prettier和ESLint"><a href="#Prettier和ESLint" class="headerlink" title="Prettier和ESLint"></a><code>Prettier</code>和<code>ESLint</code></h3><p>npm 安装这两个，要它们生效都需要使用命令行，例如<code>prettier --write</code>和<code>eslint --fix</code><br>如果需要 vscode 保存就生效，vscode 需要安装对应插件</p>
<p><code>Prettier</code>对应的<code>settins.json</code>配置</p>
<pre><code>&#123;
    ...
    // 新增如下配置
    &quot;editor.formatOnType&quot;: true,
    &quot;editor.formatOnSave&quot;: true,
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,
    &quot;[javascript]&quot;: &#123;
        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
      &#125;,
      &quot;[typescript]&quot;: &#123;
        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
      &#125;,
      &quot;[typescriptreact]&quot;: &#123;
        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
      &#125;,
      &quot;[html]&quot;: &#123;
        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
      &#125;,
      &quot;[json]&quot;: &#123;
        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
      &#125;,
      &quot;[scss]&quot;: &#123;
        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
      &#125;,
      &quot;[jsonc]&quot;: &#123;
        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
      &#125;,
&#125;
</code></pre>
<p><code>ESLint</code>对应<code>setting.json</code>配置</p>
<pre><code> &quot;editor.codeActionsOnSave&quot;: &#123;
        &quot;source.fixAll.eslint&quot;: true
    &#125;,
</code></pre>
<h2 id="VSCode-安装的-eslint-和-prettier-插件和-npm-安装的有什么区别"><a href="#VSCode-安装的-eslint-和-prettier-插件和-npm-安装的有什么区别" class="headerlink" title="VSCode 安装的 eslint 和 prettier 插件和 npm 安装的有什么区别"></a>VSCode 安装的 eslint 和 prettier 插件和 npm 安装的有什么区别</h2><p>VSCode 中安装的是在编辑器里面用的，如果项目根目录下有 eslintrc 和 prettierrc 配置文件，VSCode 插件会自动读取配置文件中的配置检查你的代码和格式化文件，npm 安装的是在命令行中运行的。如果你只安装 npm 包，VSCode 是不会有 lint 提示的，只能通过命令行，在小黑窗查看不符合 lint 规则的检测信息。安装 npm 包最主要的原因是可以通过 git hook 强制提交代码前 lint 和格式化代码保证代码仓库的代码风格统一。</p>
<p><a href="https://blog.theodo.com/2019/08/empower-your-dev-environment-with-eslint-prettier-and-editorconfig-with-no-conflicts/">参考链接</a></p>
<p><a href="https://juejin.cn/post/6924568874700505102">参考链接</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/03/Flex%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luzy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Luzy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/03/Flex%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">Flex布局理解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-03 10:41:52" itemprop="dateCreated datePublished" datetime="2024-09-03T10:41:52+08:00">2024-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/Flex%E5%B8%83%E5%B1%80/" itemprop="url" rel="index"><span itemprop="name">Flex布局</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="flex语法"><a href="#flex语法" class="headerlink" title="flex语法"></a>flex语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex: [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt; ];</span><br><span class="line"></span><br><span class="line">flex:auto;</span><br><span class="line"></span><br><span class="line">flex:none;</span><br></pre></td></tr></table></figure>
<h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><p>CSS语法中的特殊符号的含义绝大多数就是正则表达式中的含义，例如单管道符<code>|</code>,方括号<code>[]</code>,问号<code>?</code>,个数范围花括号<code>&#123;&#125;</code>等。</p>
<p>首先是单管道符<code>|</code>。表示排他。也就是这个符号前后的属性值都支持的，且不能同时出现。因此下面语法是支持的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex: [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt; ];</span><br><span class="line"></span><br><span class="line">flex:auto;</span><br><span class="line"></span><br><span class="line">flex:none;</span><br></pre></td></tr></table></figure>

<p>接下来，<code>[...]</code>这一部分。其中方括号<code>[]</code>表示范围。也就是支持的属性值在这个范围内。我们先把方括号<code>[]</code>内其他特殊字符去除，可以得到下面的语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex: auto;</span><br><span class="line">flex: none;</span><br><span class="line"></span><br><span class="line">flex: [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt; &lt;&#x27;flex-basis&#x27;&gt; ]</span><br></pre></td></tr></table></figure>
<p>这就是说，flex属性支持空格分隔的3个值，因此，下面的语法都是支持的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex: auto;</span><br><span class="line">flex: none;</span><br><span class="line">/* 3个值 */</span><br><span class="line">flex: 1 1 100px;</span><br></pre></td></tr></table></figure>

<p>再看方括号<code>[]</code>内的其他字符，例如问号<code>?</code>,表示0个或1个。也就是<code>flex-shrink</code>属性可有可无。因此，flex属性值也可以是2个值。因此，下面的语法都是支持的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex: auto;</span><br><span class="line">flex: none;</span><br><span class="line">/* 2个值 */</span><br><span class="line">flex: 1 100px;</span><br><span class="line">/* 3个值 */</span><br><span class="line">flex: 1 1 100px;</span><br></pre></td></tr></table></figure>

<p>最后看双管道符号<code>||</code>,是或者的意思。表示前后可以分开独立合法使用。也就是<code>flex:flex-grow flex-shrink?</code>和<code>flex-basis</code>都是合法的。于是我们又多了2种合法的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flex:auto;</span><br><span class="line">flex:none;</span><br><span class="line">/**1个值，flex-grow**/</span><br><span class="line">flex:1;</span><br><span class="line">/**1个值,flex-basis**/</span><br><span class="line">flex:100px</span><br><span class="line">/**2个值，flex-grow和flex-basis**/</span><br><span class="line">flex:1 100px</span><br><span class="line">/**2个值，flex-grow和flex-shrink**/</span><br><span class="line">flex:1 1;</span><br><span class="line">/**3个值**/</span><br><span class="line">flex:1 1 100px</span><br></pre></td></tr></table></figure>

<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>指定了容器剩余空间<strong>多余</strong>时候的分配规则。默认值是<code>0</code>,多余空间不分配</br></p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>制定了容器剩余空间不足的时候的分配规则，默认值是<code>1</code>,空间不足要分配。</p>
<p>如果所有的项目<code>flex-shrink</code>属性为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>指定了固定的分配数量</p>
<p><strong>浏览器根据这个属性，计算主轴是否有多余空间。它默认值为<code>auto</code>，即项目的本来大小</strong></p>
<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值，则项目将占据固定空间</p>
<h3 id="flex的几个简写"><a href="#flex的几个简写" class="headerlink" title="flex的几个简写"></a>flex的几个简写</h3><ul>
<li>flex:1</br><br><code>flex: 1 1 0</code></li>
<li>flex:auto</br><br><code>flex:1 1 auto</code></li>
<li>flex:initial</br><br><code>flex:0 1 auto</code></li>
<li>flex:none<br><code>flex:0 0 auto</code></li>
</ul>
<p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">参考链接1</a></p>
<p><a href="http://www.ayqy.net/blog/flexbox%E5%B8%83%E5%B1%80%E6%8C%87%E5%8D%97/">参考链接2</a></p>
<p><a href="https://www.zhangxinxu.com/wordpress/2019/12/css-flex-deep/">参考链接3</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/03/Git%E7%9A%84%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luzy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Luzy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/03/Git%E7%9A%84%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Git的常规操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-03 10:41:52" itemprop="dateCreated datePublished" datetime="2024-09-03T10:41:52+08:00">2024-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Git实战总结"><a href="#Git实战总结" class="headerlink" title="Git实战总结"></a>Git实战总结</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ul>
<li><p>废话不多少说，先上图<br><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014061202.jpg" alt="Git流程图"></p>
</li>
<li><p><strong>工作区</strong>：顾名思义就是你本地工作的地方</p>
</li>
<li><p><strong>暂存区</strong>：位于文件夹<code>/.git/index</code>（我们执行 <code>git add</code>命令就是将文件提交到暂存区）</p>
</li>
<li><p><strong>本地仓库</strong>：就是我们电脑上保存版本数据的地方。位于文件夹<code>/.git/object</code>（我觉得这就是Git厉害的地方，分布式每个人都有自己的一个仓库，不用联网就可以提交）</p>
</li>
<li><p><strong>远程仓库</strong>：我们用Git多人协作，怎么保持跟别人的代码同步呢，就是靠我们自己的本地仓库和远程仓库之间进行对应的拉取(pull)和推送(push)操作。</p>
</li>
</ul>
<h2 id="二、日常我们需要进行的操作场景，十万个怎么办"><a href="#二、日常我们需要进行的操作场景，十万个怎么办" class="headerlink" title="二、日常我们需要进行的操作场景，十万个怎么办"></a>二、日常我们需要进行的操作场景，十万个怎么办</h2><p>1、<strong>Q:  修改了某个文件，还没(commit)提交，想还原怎么办？</strong><br> A：<code>git checkout [filename]</code> </p>
<p>2、<strong>Q：执行了<code>git commit -m &#39;message&#39;</code>操作，想撤回怎么办？</strong><br>A：<code>git reset --hard [commit]</code>回退到你想回退的版本号 。</p>
<ul>
<li><code>--hard</code>表示本地仓库，暂存区和你的工作区全部恢复。</li>
<li><code>--soft</code>表示只恢复本地仓库。</li>
<li><code>--mixed</code>表示只恢复本地仓库和暂存区，如果不写，默认是<code>--mixed</code></li>
</ul>
<p>3、<strong>Q：执行了<code>git push</code>操作，想撤回怎么办？</strong><br>A：</p>
<ul>
<li><code>git reset --hard [commit]</code> 将本地仓库还原</li>
<li><code>git push --force</code> 将本地仓库强制推送到远程仓库</li>
</ul>
<p>4、<strong>Q：已经修改了文件，但是此时要切换到其他分支，处理紧急情况，文件又不想提交怎么办？</strong><br>A：</p>
<ul>
<li><code>git stash</code> 先将文件保存到暂存区然后切换到你想去的分支</li>
<li><code>git stash pop</code>当回到当前分支时候释放暂存区里面之前修改的代码</li>
</ul>
<p>5、<strong>Q：想删除本地分支，怎么办？</strong><br>A：<code>git branch -d &lt;local-branchname&gt;</code> 注意此时你不应该在你想要删除的这个分支上操作</p>
<p>6、<strong>Q：想删除远程分支，怎么办?</strong><br>A：<code>git push origin :&lt;remote-branchname&gt;</code>就是推送一个空的本地分支到你想删除的远程分支即删除了</p>
<p>7、<strong>Q：本地分支名字取的不好，想重命名怎么办?</strong><br>A：<code>git branch -m &lt;new-branch-name&gt;</code></p>
<p>8、<strong>Q：想创建并切换到一个本地分支怎么办？</strong><br>A：<code>git checkout -b &lt;branch-name&gt;</code></p>
<p>9、<strong>Q：想创建分支并切换到一个本地分支，还要这个本地分支关联上对应的远程分支，怎么办？</strong><br>A：<code>git checkout -b &lt;branch-name&gt; orgin/&lt;branch-name&gt;</code></p>
<p>10、<strong>Q：想删除某个已经提交到远程仓库的文件怎么办？</strong><br>A：</p>
<ul>
<li><code>git rm -f --cached [filename]</code> 从暂存区删除文件</li>
<li><code>git commit -m &quot;message&quot;</code> 提交</li>
<li><code>git push origin master</code> 推送到远程仓库</li>
</ul>
<p>11、 <strong>Q:想将本地项目关联到远程仓库并推送怎么办</strong></p>
<ul>
<li><code>git remote add origin git@github.com:lzyup/vueComponentLearn.git</code></li>
<li><code>git push -u origin master</code></li>
</ul>
<p>12、 <strong>Q:如何打上tag并推送</strong></p>
<ul>
<li><code>git tag -a v1.4 -m &quot;my version 1.4&quot;</code></li>
<li><code>git push origin v1.4</code>(提交单个标签)</li>
<li><code>git push origin --tags</code>(提交全部tag)</li>
</ul>
<p>13、<strong>Q:如何检出指定tag</strong></p>
<ul>
<li><code>git checkout -b [branchname] [tagname]</code></li>
</ul>
<p>14、 <strong>Q:如何显示本地tag</strong></p>
<ul>
<li><code>git tag</code></li>
</ul>
<p>15、<strong>Q:如何删除tag</strong></p>
<ul>
<li><code>git tag -d [tagname]</code>（删除本地tag）</li>
<li><code>git push origin :refs/tags/[tagname]</code>(用push,删除远程tag)</li>
</ul>
<h2 id="三、容易混淆的概念理解"><a href="#三、容易混淆的概念理解" class="headerlink" title="三、容易混淆的概念理解"></a>三、容易混淆的概念理解</h2><ul>
<li><strong><code> git fetch</code>:</strong> 取回所有分支的更新，通过这个命令取回的代码对你本地开发的代码是没有影响的。</li>
<li><strong><code>git pull = git fetch + git merge</code></strong></li>
</ul>
<p><strong>以上就是我常遇到的一些场景希望能帮助到你</strong></p>
<h2 id="四、附加两个最常用的命令的全称"><a href="#四、附加两个最常用的命令的全称" class="headerlink" title="四、附加两个最常用的命令的全称"></a>四、附加两个最常用的命令的全称</h2><pre><code>$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;

$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;

$ git remote add &lt;主机名&gt; &lt;网址&gt;

用于添加远程主机

$ git fetch &lt;远程主机名&gt;

将某个远程主机的更新，全部取回本地
git fetch 通常用来查看他人的进程，因为它取回的代码对你本地开发代码没有影响
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/03/Hooks%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luzy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Luzy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/03/Hooks%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">Hooks基本用法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-03 10:41:52" itemprop="dateCreated datePublished" datetime="2024-09-03T10:41:52+08:00">2024-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/React/Hooks/" itemprop="url" rel="index"><span itemprop="name">Hooks</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="什么是Hooks"><a href="#什么是Hooks" class="headerlink" title="什么是Hooks"></a>什么是Hooks</h3><p>Hooks是一种函数，该函数允许您从函数式组件“勾住(hook into)”React状态和生命周期功能</p>
<h3 id="有哪些钩子"><a href="#有哪些钩子" class="headerlink" title="有哪些钩子"></a>有哪些钩子</h3><p>基本钩子：<code>useState</code>、<code>useEffect</code>、<code>useContext</code></br><br>额外的钩子：<code>useCallback</code>、<code>useReducer</code>、<code>userMemo</code>、<code>useRef</code>、<code>useLayoutEffect</code>、<code>useImperativeHandle</code>、<code>useDebugValue</code></p>
<h3 id="不同钩子的用法"><a href="#不同钩子的用法" class="headerlink" title="不同钩子的用法"></a>不同钩子的用法</h3><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a><code>useState</code></h4><p>创建于一个新的状态，参数为一个固定的值或者一个有返回值的方法。钩子执行后的结果为一个<strong>数组</strong>，分别为生成的状态以及改变状态的方法，通过解构赋值的方法拿到对应的值和方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [count, changeCount] = useState(0);</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是</strong>：<code>useState</code>相较于类组件的<code>setState</code>的非覆盖式更新改变，<code>useState</code> 覆盖式更新状态，需要开发者自己处理逻辑比如<code>setobject(&#123;...obj,count:1&#125;)</code></p>
<h4 id="useEffect（每次render都会执行）"><a href="#useEffect（每次render都会执行）" class="headerlink" title="useEffect（每次render都会执行）"></a><code>useEffect</code>（每次render都会执行）</h4><p>执行副作用钩子，所有的副作用在组件挂在完成后会执行一次，如果副作用存在返回的函数，那么返回的函数将在卸载时运行。主要应用于以下两种情况</br><br>1、函数式组件中不存在类组件的生命周期，如果我们需要在一些特定的生命周期或者变化后做一些操作的话，必须借助<code>useEffect</code>的一些特性去实现。</p>
<p>2、useState产生的changeState方法并没有提供类似于setState的第二个参数一样的功能，因此如果需要在State改变后执行一些方法，必须通过useEffect实现</p>
<p>该钩子接受两个参数：第一个参数为副作用需要执行回调，生成的回调方法可以返回一个函数（<strong>将在组件卸载时运行</strong>）；第二个为该副作用监听的状态数组。当对应状态发生变动时会执行副作用，<strong>如果第二个参数为空，那么在每一个State变化时都会执行该副作用</strong></br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const [count, changeCount] = useState(0);</span><br><span class="line"></span><br><span class="line">// 将在count变化时打印最新的count数据</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  message.info(`count发生变动，最新值为$&#123;count&#125;`);</span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure>

<p>如何应用第一种情况呢，分析我们需要的是让目标副作用在初始化执行一次后再也不会被调用，于是只要让与该副作用相关联的状态为空(空数组)，不管其他状态如何变化，该副作用都不会再次执行，就实现了<code>componentDidMount</code>和<code>componentWillUnmount</code>的功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    message.info(&#x27;我只在页面挂载时打印&#x27;);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      message.info(&#x27;我只在页面卸载时打印&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure>

<h4 id="useCallback-缓存函数"><a href="#useCallback-缓存函数" class="headerlink" title="useCallback(缓存函数)"></a><code>useCallback</code>(缓存函数)</h4><p>生成Callback的钩子。用于不同的<code>useEffect</code>中存在的相同逻辑的封装，减少代码冗余，配合<code>useEffect</code>使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const [count1, changeCount1] = useState(0);</span><br><span class="line">const [count2, changeCount2] = useState(10);</span><br><span class="line"></span><br><span class="line">const calculateCount = useCallback(() =&gt; &#123;</span><br><span class="line">  if (count1 &amp;&amp; count2) &#123;</span><br><span class="line">    return count1 * count2;</span><br><span class="line">  &#125;</span><br><span class="line">  return count1 + count2;</span><br><span class="line">&#125;, [count1, count2])</span><br><span class="line"></span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    const result = calculateCount(count, count2);</span><br><span class="line">    message.info(`执行副作用，最新值为$&#123;result&#125;`);</span><br><span class="line">&#125;, [calculateCount])</span><br></pre></td></tr></table></figure>

<p>在使用<code>useCallback</code>生成计算的回调后，在使用该回调的副作用中，<strong>第二个参数应该是生成的回调</strong><br>此时<code>useCallback</code>和<code>useEffect</code>是按顺序执行的，实现了副作用逻辑的抽离</p>
<h4 id="useRef-可以绕过Hooks的Capture-Value特性"><a href="#useRef-可以绕过Hooks的Capture-Value特性" class="headerlink" title="useRef(可以绕过Hooks的Capture Value特性)"></a><code>useRef</code>(可以绕过Hooks的Capture Value特性)</h4><ul>
<li>获取DOM元素的节点</li>
<li>获取子组件的实例</li>
<li>渲染周期之间共享数据的存储（state不能存储跨渲染周期的数据，因为state的保存会触发组件重渲染）</br><br><code>useRef</code>接受一个参数，为ref的初始值。类似类组件的<code>createRef</code>方法，该钩子会返回一个对象，对象中的current字段为我们<strong>指向实例&#x2F;保存的变量</strong>,可以实现获得目标节点实例或保存状态的功能。</li>
</ul>
<p><strong>useRef保存的变量不会随着每次数据的变化重新生成，而是保持在我们最后一次赋值时的状态，依靠这种特性，在配合useCallback和useEffect我们可以实现preProps&#x2F;preState的功能。</strong></p>
<h4 id="useMemo（React-memo）（缓存值）"><a href="#useMemo（React-memo）（缓存值）" class="headerlink" title="useMemo（React.memo）（缓存值）"></a><code>useMemo</code>（React.memo）（缓存值）</h4><p>Memo为Memory简写，<code>useMemo</code>即使用记忆的内容。该钩子主要用于性能的优化。</p>
<p>在业务中，我们可以用<code>useMemo</code>来处理计算结果的缓存或引入组件来防止重复挂载优化。其接受两个参数，第一个参数为<code>Getter</code>方法，<strong>返回值为要缓存的数据或组件</strong>，第二个参数为该返回值相关联的状态，当其中任何一个状态发生变化时就会重新调用Getter方法生成新的返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const calculateCount = useMemo(() =&gt; &#123;</span><br><span class="line">   message.info(&#x27;重新生成计算结果&#x27;);</span><br><span class="line">   return count1 * 10;</span><br><span class="line"> &#125;, [count1]);</span><br><span class="line"> </span><br><span class="line"> //返回组件</span><br><span class="line">   const child = useMemo(() =&gt; &#123;</span><br><span class="line">   message.info(&#x27;重新生成Child组件&#x27;);</span><br><span class="line">   return &lt;Child count=&#123;count1&#125; /&gt;;</span><br><span class="line"> &#125;, [count1]);</span><br><span class="line"> return (</span><br></pre></td></tr></table></figure>


<h3 id="useCallback和useMemo"><a href="#useCallback和useMemo" class="headerlink" title="useCallback和useMemo"></a><code>useCallback</code>和<code>useMemo</code></h3><p><code>useCallback</code>是根据以来缓存第一个入参的(callback)。<code>useMemo</code>是根据依赖(deps)缓存第一个入参(allback)执行后的值</p>
<h3 id="编写自己的钩子"><a href="#编写自己的钩子" class="headerlink" title="编写自己的钩子"></a>编写自己的钩子</h3><p>钩子并不是什么高深莫测的东西，它只是对我们常用逻辑的一些封装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123; useState &#125; from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">//编写我们自己的hook,名字以use开头</span><br><span class="line">funtion useCounter(initialValue)&#123;</span><br><span class="line">    //接受初始化值生成state</span><br><span class="line">    const [count,changeCount] = useState(initialValue)</span><br><span class="line">    //声明减少的方法</span><br><span class="line">    const decrease = () =&gt;&#123;</span><br><span class="line">        changeCount(count - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    //声明增加的方法</span><br><span class="line">    const increase = () =&gt;&#123;</span><br><span class="line">        changeCount(count + 1)</span><br><span class="line">    &#125;</span><br><span class="line">    //声明重置计数器方法</span><br><span class="line">    const resetCounter = () =&gt;&#123;</span><br><span class="line">        changeCount(0)</span><br><span class="line">    &#125;</span><br><span class="line">    //将count数字与方法返回回去</span><br><span class="line">    return [count,&#123;decrease,increase,resetCounter&#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function myHooksView() &#123;</span><br><span class="line">  // 在函数组件中使用我们自己编写的hook生成一个计数器，并拿到所有操作方法的对象</span><br><span class="line">  const [count, controlCount] = useCounter(10);</span><br><span class="line">  return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        当前数量：&#123;count&#125;</span><br><span class="line">            &lt;button onClick=&#123;controlCount.decrease&#125;&gt;减少&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;controlCount.increase&#125;&gt;增加&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;controlCount.resetCounter&#125;&gt;重置&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>钩子</th>
<th>用法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>useState</td>
<td>const [state,changeState] &#x3D; useState(initialValue)</td>
<td>用于生成状态以及改变状态</td>
</tr>
<tr>
<td>useEffect</td>
<td>useEffect(fn,[…relativeState])</td>
<td>用于生成与状态绑定的副作用</td>
</tr>
<tr>
<td>useCallback</td>
<td>useCallback(fn,[…relativeState])</td>
<td>用于生成与状态绑定的回调函数</td>
</tr>
<tr>
<td>useMemo</td>
<td>useMemo(fn,[…relativeState])</td>
<td>用于生成与状态绑定的组件&#x2F;计算结果</td>
</tr>
<tr>
<td>useRef</td>
<td>const newRef &#x3D; useRef(initialValue)</td>
<td>用于获取节点实例&#x2F;数据保存</td>
</tr>
</tbody></table>
<p><a href="https://github.com/happylindz/blog/issues/19">示例</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/03/AST%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luzy's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Luzy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/03/AST%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">AST解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-03 10:41:52" itemprop="dateCreated datePublished" datetime="2024-09-03T10:41:52+08:00">2024-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JS%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">JS相关</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JS%E7%9B%B8%E5%85%B3/ast/" itemprop="url" rel="index"><span itemprop="name">ast</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1、什么是-AST"><a href="#1、什么是-AST" class="headerlink" title="1、什么是 AST"></a>1、什么是 AST</h2><p>Abstract Syntax Tree(抽象语法树)，源代码经过词法分析、语法分析后产生的用来描述源代码的一种树状结构就是抽象语法树.<a href="https://astexplorer.net/">AST 在线转换</a>。</p>
<ul>
<li><p>词法分析<br>代码字符串被分解成一系列标记（tokens）,每个标记代表一个基本的词法单元(如关键字、运算符、标识符、文字等)。这个阶段生成的标记流是解析器输入的基础</p>
</li>
<li><p>语法分析<br>解析器接收标记流并将其转换为一个树结构，即 AST 在这一步，解析器按照语言的语法规则来构建树的结构，确保代码的语法正确</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 解析器，该包可以将原始js代码转换为 AST 结构</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">// 遍历器，用来递归遍历 AST 中的所有节点, 找到我们期望操作的节点</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">// 类型操作器，用来判断节点类型,构造新的节点</span><br><span class="line">const t = require(&quot;@babel/types&quot;);</span><br><span class="line">// 生成器，用来将AST转换为 JS 代码</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line">// 读取要分析的代码源文件</span><br><span class="line">const jscode = fs.readFileSync(&quot;./testData.js&quot;, &#123;</span><br><span class="line">    encoding: &quot;utf-8&quot;</span><br><span class="line">&#125;);</span><br><span class="line">// 生成 ast</span><br><span class="line">let ast = parser.parse(jscode);</span><br><span class="line"></span><br><span class="line">// ----------- 这里编写期望的逻辑代码，操作修改 ast ---------</span><br><span class="line">// ----------------------------------------------------</span><br><span class="line"></span><br><span class="line">// 根据 ast 生成新的 js 代码， 这里使用了 compact 是对代码进行压缩</span><br><span class="line">let &#123;code&#125; = generator(ast, opts = &#123;compact:true&#125;)</span><br><span class="line">console.log(code)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Luzy</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
